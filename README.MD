# Bitonic sort on OpenCL

Этот проект реализует алгоритм битонной (битонической) сортировки с использованием OpenCL. [Битоническая сортировка](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D1%82%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0) — это параллельный алгоритм сортировки, хорошо подходящий ускорению на GPU. Проект включает в себя OpenCL-кернелы и класс Ocl, реализующий логику сортировки.


# Сборка

 Создайте папку ./build, и сконфигурируйте проект

 ```
mkdir build
cd build
cmake ..
make
 ```

# Использование

Чтобы использовать битоническую сортировку в вашем проекте, необходимо создать экземпляр класса ```Ocl```, который находится в файле ```ocl.hpp```, передав в конструктор путь до кернела. После этого нужно передать данные для сортировки, запустить её и получить результат.
```
#include "ocl.hpp"
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    int N = 1 << 24;
    std::vector<int> v(N);
    std::iota(v.rbegin(), v.rend(), 100);
    
    Ocl app("path_to_kernel");
    
    // Загрузка данных
    app.writeToBuf(v.data(), N);
    
    // Запуск сортировки
    app.run();
    
    // Считывание результата
    app.readFromBuf(v.data());
    
    // v - 100, 101, 102 ...
}
```

# Сравнение производительности

Чтобы сравнить производительность реализации на OpenCL с ```std::sort```, запустите бенчмарки:
```
cd build
make
./benchark/bench_o2
```

Сравнение производительности происходит относительно ```std::sort``` (БЕЗ УЧЁТА ЗАГРУЗКИ/ВЫГРУЗКИ ДАННЫХ С ВИДЕОКАРТЫ) с оптимизациями -O2. Результаты бенчмарков на моём железе:
* GPU -- (GeForce RTX 4060 Max-Q / Mobile)
* CPU -- (13th Gen Intel(R) Core(TM) i7-13620H)

![Результаты сравнения](pictures/results.png)
